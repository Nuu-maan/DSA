# Advanced Linked Lists

This section contains advanced linked list problems with multiple ES6+ solution approaches. These are challenging variants of classic linked list problems that require deeper understanding of data structures and algorithms.

## Problems

### 1. Merge k Sorted Lists with Custom Comparator
**Source:** LeetCode Hard variant

Merge k sorted linked lists into one sorted list using a custom comparator function. This variant allows for flexible sorting criteria beyond simple numeric comparison.

**Approaches:**
- Sequential merge with custom comparator
- Divide and conquer (merge sort approach) with custom comparator
- Min-heap approach with custom comparator
- Functional approach using array methods with custom comparator
- Priority queue using Map with custom comparator
- Generator function for step-by-step visualization

### 2. Reverse Nodes in k-Group with Custom Reversal Logic
**Source:** LeetCode Hard variant

Reverse the nodes of a linked list k at a time, but with custom reversal logic that can implement different reordering patterns within each group.

**Approaches:**
- Iterative approach with custom reversal logic
- Recursive approach with custom reversal logic
- Stack-based approach with custom reversal logic
- Functional approach using array conversion with custom reversal logic
- Two-pointer approach with group tracking and custom reversal logic
- Generator function for step-by-step visualization

### 3. Copy List with Random Pointer and Metadata
**Source:** LeetCode Hard variant

Construct a deep copy of a linked list where each node contains a random pointer and additional metadata that must also be deep copied.

**Approaches:**
- HashMap approach (Two-pass) with deep metadata copy
- Interweaving nodes approach (Three-pass) with metadata copy
- Recursive approach with memoization and metadata copy
- Functional approach using array conversion with metadata copy
- Array-based approach with index mapping and metadata copy
- Generator function for step-by-step visualization

## Solution Approaches

Each problem is solved with multiple approaches showcasing different JavaScript features:
Each problem is solved with multiple approaches:

1. Traditional iterative approach
2. Recursive approach
3. Functional programming approach
4. ES6+ optimized approach
5. Generator function for step-by-step visualization
6. Brute force approach for comparison

## Testing

Each solution includes comprehensive test cases and performance comparisons.
